<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HACKER TETRIS - MAQSADBEK SYSTEMS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: #000;
            color: #39ff14;
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #watermark {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 15vw;
            font-weight: bold;
            color: rgba(57, 255, 20, 0.03);
            pointer-events: none;
            z-index: 1;
            letter-spacing: 0.5em;
            white-space: nowrap;
            user-select: none;
        }

        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.15;
        }

        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.98; }
            50% { opacity: 1; }
            100% { opacity: 0.97; }
        }

        #game-container {
            position: relative;
            z-index: 10;
            text-align: center;
            padding: 20px;
            max-width: 100vw;
        }

        #title {
            font-size: clamp(16px, 5vw, 32px);
            margin-bottom: 15px;
            text-shadow: 0 0 10px #39ff14, 0 0 20px #39ff14;
            animation: glitch 5s infinite;
            letter-spacing: 0.2em;
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); }
            91% { transform: translate(-2px, 2px); }
            93% { transform: translate(2px, -2px); }
            95% { transform: translate(-2px, -2px); }
        }

        #intro-screen, #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
        }

        .intro-text {
            font-size: clamp(14px, 3vw, 20px);
            margin: 10px 0;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        .intro-text:nth-child(1) { animation-delay: 0.5s; }
        .intro-text:nth-child(2) { animation-delay: 1s; }
        .intro-text:nth-child(3) { animation-delay: 1.5s; }
        .intro-text:nth-child(4) { animation-delay: 2s; }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .neon-button {
            background: transparent;
            border: 2px solid #39ff14;
            color: #39ff14;
            padding: 15px 30px;
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(14px, 3vw, 18px);
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 0 10px #39ff14, inset 0 0 10px rgba(57, 255, 20, 0.1);
            transition: all 0.3s;
            letter-spacing: 0.1em;
        }

        .neon-button:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 20px #39ff14, inset 0 0 20px rgba(57, 255, 20, 0.3);
            transform: scale(1.05);
        }

        .neon-button:active {
            transform: scale(0.95);
        }

        #game-area {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #stats-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .stat-box {
            border: 2px solid #00f5ff;
            padding: 10px 20px;
            background: rgba(0, 245, 255, 0.05);
            box-shadow: 0 0 10px #00f5ff;
            min-width: 100px;
        }

        .stat-label {
            font-size: 12px;
            color: #00f5ff;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            text-shadow: 0 0 5px #39ff14;
        }

        #canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        #tetris-canvas {
            border: 3px solid #39ff14;
            box-shadow: 0 0 20px #39ff14, inset 0 0 20px rgba(57, 255, 20, 0.1);
            background: rgba(0, 0, 0, 0.8);
            display: block;
        }

        #next-preview {
            position: absolute;
            top: 10px;
            right: -140px;
            border: 2px solid #00f5ff;
            background: rgba(0, 245, 255, 0.05);
            padding: 10px;
            box-shadow: 0 0 10px #00f5ff;
        }

        #next-label {
            font-size: 14px;
            color: #00f5ff;
            margin-bottom: 5px;
        }

        #next-canvas {
            display: block;
            background: rgba(0, 0, 0, 0.5);
        }

        #controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: 20px auto;
        }

        .control-btn {
            background: rgba(57, 255, 20, 0.1);
            border: 2px solid #39ff14;
            color: #39ff14;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            padding: 20px;
            cursor: pointer;
            box-shadow: 0 0 10px #39ff14;
            transition: all 0.1s;
            user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(57, 255, 20, 0.3);
            transform: scale(0.95);
        }

        .control-btn.wide {
            grid-column: span 3;
        }

        #toggle-matrix {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 150;
            padding: 8px 15px;
            font-size: 12px;
        }

        #pause-menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #39ff14;
            padding: 30px;
            z-index: 250;
            box-shadow: 0 0 30px #39ff14;
        }

        #pause-menu h2 {
            margin-bottom: 20px;
            text-shadow: 0 0 10px #39ff14;
        }

        @media (max-width: 768px) {
            #next-preview {
                position: static;
                margin: 10px auto;
            }

            #controls {
                display: grid;
            }

            #game-area {
                padding-bottom: 20px;
            }
        }

        @media (min-width: 769px) {
            #keyboard-hint {
                font-size: 14px;
                color: #00f5ff;
                margin-top: 10px;
                opacity: 0.7;
            }
        }

        .pulse {
            animation: pulse 0.3s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px #39ff14; }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        #game-over-text {
            font-size: clamp(24px, 6vw, 48px);
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            margin-bottom: 20px;
            animation: glitch 1s infinite;
        }

        #final-score {
            font-size: clamp(18px, 4vw, 28px);
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div id="watermark">MAQSADBEK</div>
    <canvas id="matrix-canvas"></canvas>
    <div id="scanlines"></div>

    <button id="toggle-matrix" class="neon-button">TOGGLE MATRIX RAIN</button>

    <div id="intro-screen">
        <div class="intro-text">&gt; INITIALIZING HACKER TETRIS...</div>
        <div class="intro-text">&gt; MAQSADBEK SYSTEMS v1.0</div>
        <div class="intro-text">&gt; LOADING TERMINAL INTERFACE...</div>
        <div class="intro-text">&gt; READY</div>
        <button class="neon-button" id="start-btn" style="margin-top: 30px; opacity: 0; animation: fadeIn 0.5s 2.5s forwards;">START GAME</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <div id="game-over-text">SYSTEM CRASHED</div>
        <div id="final-score"></div>
        <button class="neon-button" id="restart-btn">REBOOT SYSTEM</button>
        <button class="neon-button" id="back-to-menu">MAIN MENU</button>
    </div>

    <div id="pause-menu">
        <h2>SYSTEM PAUSED</h2>
        <button class="neon-button" id="resume-btn">RESUME</button>
        <button class="neon-button" id="quit-btn">QUIT</button>
    </div>

    <div id="game-container">
        <div id="title">HACKER TETRIS - MAQSADBEK SYSTEMS</div>
        
        <div id="game-area">
            <div id="stats-container">
                <div class="stat-box">
                    <div class="stat-label">SCORE</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">LEVEL</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">LINES</div>
                    <div class="stat-value" id="lines">0</div>
                </div>
            </div>

            <div id="canvas-wrapper">
                <canvas id="tetris-canvas" width="300" height="600"></canvas>
                <div id="next-preview">
                    <div id="next-label">NEXT</div>
                    <canvas id="next-canvas" width="100" height="100"></canvas>
                </div>
            </div>

            <div id="keyboard-hint">
                ← → ↑ ↓ ARROWS | SPACE: HARD DROP | R: RESTART | P: PAUSE
            </div>

            <div id="controls">
                <button class="control-btn" id="btn-left">←</button>
                <button class="control-btn" id="btn-rotate">↻</button>
                <button class="control-btn" id="btn-right">→</button>
                <button class="control-btn" id="btn-down">↓</button>
                <button class="control-btn wide" id="btn-drop">HARD DROP</button>
            </div>
        </div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = {
            I: '#00f5ff',
            O: '#ffff00',
            T: '#ff00ff',
            L: '#ff8800',
            J: '#0000ff',
            S: '#00ff00',
            Z: '#ff0000'
        };

        const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]],
            J: [[1,0,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]]
        };

        class Tetris {
            constructor() {
                this.canvas = document.getElementById('tetris-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nextCanvas = document.getElementById('next-canvas');
                this.nextCtx = this.nextCanvas.getContext('2d');
                
                this.board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.gameOver = false;
                this.paused = false;
                
                this.currentPiece = null;
                this.currentX = 0;
                this.currentY = 0;
                this.nextPiece = null;
                
                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.lastTime = 0;
                
                this.setupControls();
                this.spawnPiece();
                this.spawnPiece();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver || this.paused) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.move(-1);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.move(1);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.softDrop();
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            this.rotate();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.hardDrop();
                            break;
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        this.restart();
                    }
                    if (e.key === 'p' || e.key === 'P') {
                        e.preventDefault();
                        this.togglePause();
                    }
                });

                document.getElementById('btn-left').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameOver && !this.paused) this.move(-1);
                });
                document.getElementById('btn-right').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameOver && !this.paused) this.move(1);
                });
                document.getElementById('btn-rotate').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameOver && !this.paused) this.rotate();
                });
                document.getElementById('btn-down').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameOver && !this.paused) this.softDrop();
                });
                document.getElementById('btn-drop').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameOver && !this.paused) this.hardDrop();
                });
            }

            spawnPiece() {
                if (!this.nextPiece) {
                    const types = Object.keys(SHAPES);
                    this.nextPiece = {
                        type: types[Math.floor(Math.random() * types.length)],
                        shape: null
                    };
                    this.nextPiece.shape = SHAPES[this.nextPiece.type].map(row => [...row]);
                }

                this.currentPiece = this.nextPiece;
                this.currentX = Math.floor((COLS - this.currentPiece.shape[0].length) / 2);
                this.currentY = 0;

                const types = Object.keys(SHAPES);
                this.nextPiece = {
                    type: types[Math.floor(Math.random() * types.length)],
                    shape: null
                };
                this.nextPiece.shape = SHAPES[this.nextPiece.type].map(row => [...row]);

                if (this.checkCollision(0, 0)) {
                    this.gameOver = true;
                    this.showGameOver();
                }

                this.drawNextPiece();
            }

            checkCollision(offsetX, offsetY, piece = this.currentPiece.shape) {
                for (let y = 0; y < piece.length; y++) {
                    for (let x = 0; x < piece[y].length; x++) {
                        if (piece[y][x]) {
                            const newX = this.currentX + x + offsetX;
                            const newY = this.currentY + y + offsetY;
                            
                            if (newX < 0 || newX >= COLS || newY >= ROWS) {
                                return true;
                            }
                            if (newY >= 0 && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            move(dir) {
                if (!this.checkCollision(dir, 0)) {
                    this.currentX += dir;
                    this.draw();
                }
            }

            softDrop() {
                if (!this.checkCollision(0, 1)) {
                    this.currentY++;
                    this.score += 1;
                    this.updateScore();
                    this.draw();
                }
            }

            hardDrop() {
                let dropDistance = 0;
                while (!this.checkCollision(0, 1)) {
                    this.currentY++;
                    dropDistance++;
                }
                this.score += dropDistance * 2;
                this.updateScore();
                this.lockPiece();
                this.draw();
            }

            rotate() {
                const rotated = this.currentPiece.shape[0].map((_, i) =>
                    this.currentPiece.shape.map(row => row[i]).reverse()
                );

                if (!this.checkCollision(0, 0, rotated)) {
                    this.currentPiece.shape = rotated;
                    this.draw();
                }
            }

            lockPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const boardY = this.currentY + y;
                            const boardX = this.currentX + x;
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = this.currentPiece.type;
                            }
                        }
                    }
                }

                this.canvas.classList.add('pulse');
                setTimeout(() => this.canvas.classList.remove('pulse'), 300);

                const linesCleared = this.clearLines();
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    const points = [0, 100, 300, 500, 800];
                    this.score += points[linesCleared] * this.level;
                    this.updateScore();
                    
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
                }

                this.spawnPiece();
            }

            clearLines() {
                let linesCleared = 0;
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(COLS).fill(0));
                        linesCleared++;
                        y++;
                    }
                }
                return linesCleared;
            }

            update(time = 0) {
                if (this.gameOver || this.paused) return;

                const deltaTime = time - this.lastTime;
                this.lastTime = time;
                this.dropCounter += deltaTime;

                if (this.dropCounter > this.dropInterval) {
                    if (!this.checkCollision(0, 1)) {
                        this.currentY++;
                    } else {
                        this.lockPiece();
                    }
                    this.dropCounter = 0;
                }

                this.draw();
            }

            draw() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawBoard();
                this.drawGhost();
                this.drawPiece();
            }

            drawBoard() {
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (this.board[y][x]) {
                            this.drawBlock(x, y, COLORS[this.board[y][x]], this.ctx);
                        }
                    }
                }
            }

            drawGhost() {
                let ghostY = this.currentY;
                while (!this.checkCollision(0, ghostY - this.currentY + 1)) {
                    ghostY++;
                }

                this.ctx.globalAlpha = 0.2;
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            this.drawBlock(this.currentX + x, ghostY + y, COLORS[this.currentPiece.type], this.ctx);
                        }
                    }
                }
                this.ctx.globalAlpha = 1;
            }

            drawPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            this.drawBlock(this.currentX + x, this.currentY + y, COLORS[this.currentPiece.type], this.ctx);
                        }
                    }
                }
            }

            drawBlock(x, y, color, ctx) {
                ctx.fillStyle = color;
                ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.shadowBlur = 0;
            }

            drawNextPiece() {
                this.nextCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);

                const offsetX = (this.nextCanvas.width - this.nextPiece.shape[0].length * 20) / 2;
                const offsetY = (this.nextCanvas.height - this.nextPiece.shape.length * 20) / 2;

                for (let y = 0; y < this.nextPiece.shape.length; y++) {
                    for (let x = 0; x < this.nextPiece.shape[y].length; x++) {
                        if (this.nextPiece.shape[y][x]) {
                            this.nextCtx.fillStyle = COLORS[this.nextPiece.type];
                            this.nextCtx.fillRect(offsetX + x * 20, offsetY + y * 20, 20, 20);
                            this.nextCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                            this.nextCtx.strokeRect(offsetX + x * 20, offsetY + y * 20, 20, 20);
                        }
                    }
                }
            }

            updateScore() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lines').textContent = this.lines;
                
                if (Math.random() > 0.7) {
                    document.getElementById('score').classList.add('pulse');
                    setTimeout(() => document.getElementById('score').classList.remove('pulse'), 300);
                }
            }

            showGameOver() {
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('final-score').textContent = `FINAL SCORE: ${this.score} | LEVEL: ${this.level}`;
                document.getElementById('tetris-canvas').classList.add('shake');
            }

            restart() {
                this.board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.gameOver = false;
                this.paused = false;
                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.nextPiece = null;
                
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('tetris-canvas').classList.remove('shake');
                
                this.updateScore();
                this.spawnPiece();
                this.spawnPiece();
                this.draw();
            }

            togglePause() {
                if (this.gameOver) return;
                this.paused = !this.paused;
                document.getElementById('pause-menu').style.display = this.paused ? 'block' : 'none';
            }
        }

        class MatrixRain {
            constructor() {
                this.canvas = document.getElementById('matrix-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.chars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                this.fontSize = 14;
                this.columns = this.canvas.width / this.fontSize;
                this.drops = Array(Math.floor(this.columns)).fill(1);
                this.enabled = false;
            }

            draw() {
                if (!this.enabled) return;

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#39ff14';
                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    const char = this.chars[Math.floor(Math.random() * this.chars.length)];
                    this.ctx.fillText(char, i * this.fontSize, this.drops[i] * this.fontSize);
                    
                    if (this.drops[i] * this.fontSize > this.canvas.height && Math.random() > 0.975) {
                        this.drops[i] = 0;
                    }
                    this.drops[i]++;
                }
            }

            toggle() {
                this.enabled = !this.enabled;
                if (!this.enabled) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }
        }

        let game;
        let matrix;
        let animationId;

        function gameLoop(time) {
            if (game) {
                game.update(time);
            }
            if (matrix) {
                matrix.draw();
            }
            animationId = requestAnimationFrame(gameLoop);
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('intro-screen').style.display = 'none';
            document.getElementById('game-area').style.display = 'flex';
            game = new Tetris();
            matrix = new MatrixRain();
            requestAnimationFrame(gameLoop);
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            if (game) {
                game.restart();
            }
        });

        document.getElementById('back-to-menu').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('toggle-matrix').addEventListener('click', () => {
            if (matrix) {
                matrix.toggle();
            }
        });

        document.getElementById('resume-btn').addEventListener('click', () => {
            if (game) {
                game.togglePause();
            }
        });

        document.getElementById('quit-btn').addEventListener('click', () => {
            location.reload();
        });

        window.addEventListener('resize', () => {
            if (matrix) {
                matrix.canvas.width = window.innerWidth;
                matrix.canvas.height = window.innerHeight;
                matrix.columns = matrix.canvas.width / matrix.fontSize;
                matrix.drops = Array(Math.floor(matrix.columns)).fill(1);
            }
        });
    </script>
</body>
</html>