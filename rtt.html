<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAQSADBEK - Reaction Time Tester</title>
    <style>
        /* 
        TECHNICAL NOTES:
        - Uses performance.now() for microsecond-precision timing (accurate to ~0.005ms on most browsers)
        - Visual stimuli synchronized with requestAnimationFrame to ensure stimulus onset matches frame render
        - Audio stimuli use WebAudio API with scheduled start times for precise timing
        - Input latency varies by device (typical: 10-50ms mouse, 50-200ms touch)
        - Mobile browsers may delay audio playback due to autoplay policies - user gesture required
        - False starts detected when response occurs before stimulus onset
        - localStorage used only with explicit user consent for privacy compliance
        
        CUSTOMIZATION POINTS:
        - Line 850+: Default trial count (10), delay range (1000-3000ms)
        - Line 1200+: Color scheme variables
        - Line 1500+: Calibration parameters
        */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-black: #0b0b0b;
            --bg-dark: #1a1a1a;
            --neon-green: #39ff14;
            --neon-cyan: #00f5ff;
            --neon-pink: #ff10f0;
            --text-gray: #b0b0b0;
            --text-dim: #606060;
            --glow-green: 0 0 10px var(--neon-green), 0 0 20px var(--neon-green);
            --glow-cyan: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-black);
            color: var(--text-gray);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Matrix Rain Background */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.15;
            pointer-events: none;
            display: none;
        }

        #matrix-canvas.active {
            display: block;
        }

        /* Scanlines Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            opacity: 0;
            transition: opacity 0.3s;
        }

        .scanlines.active {
            opacity: 1;
        }

        /* CRT Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.5) 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .vignette.active {
            opacity: 1;
        }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        /* Header */
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid var(--neon-green);
            margin-bottom: 30px;
            position: relative;
        }

        .ascii-logo {
            font-size: clamp(12px, 3vw, 20px);
            color: var(--neon-green);
            text-shadow: var(--glow-green);
            white-space: pre;
            line-height: 1.2;
            animation: flicker 3s infinite alternate;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
            51% { opacity: 1; }
            60% { opacity: 0.98; }
        }

        .subtitle {
            color: var(--neon-cyan);
            font-size: 14px;
            margin-top: 10px;
            letter-spacing: 2px;
        }

        /* Buttons */
        button {
            background: var(--bg-dark);
            color: var(--neon-green);
            border: 2px solid var(--neon-green);
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: var(--neon-green);
            color: var(--bg-black);
            box-shadow: var(--glow-green);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        button.secondary:hover {
            background: var(--neon-cyan);
            color: var(--bg-black);
            box-shadow: var(--glow-cyan);
        }

        /* Screens */
        .screen {
            display: none;
            animation: fadeIn 0.5s;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Landing Screen */
        .landing {
            text-align: center;
            padding: 40px 20px;
        }

        .landing h1 {
            font-size: clamp(24px, 5vw, 48px);
            color: var(--neon-green);
            text-shadow: var(--glow-green);
            margin-bottom: 20px;
        }

        .landing p {
            font-size: clamp(14px, 2vw, 18px);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .start-btn {
            font-size: 20px;
            padding: 20px 50px;
            margin: 20px 10px;
        }

        /* Settings Panel */
        .settings {
            background: var(--bg-dark);
            border: 2px solid var(--neon-cyan);
            padding: 30px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            color: var(--neon-cyan);
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            background: var(--bg-black);
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }

        /* Test Screen */
        .test-area {
            min-height: 400px;
            background: var(--bg-dark);
            border: 2px solid var(--neon-green);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            padding: 40px;
            position: relative;
            text-align: center;
        }

        .test-instruction {
            font-size: 20px;
            color: var(--neon-cyan);
            margin-bottom: 20px;
        }

        .countdown {
            font-size: 72px;
            color: var(--neon-green);
            text-shadow: var(--glow-green);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .stimulus-circle {
            width: 200px;
            height: 200px;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: var(--glow-green);
            animation: stimulusPulse 0.5s infinite;
            margin: 20px auto;
        }

        @keyframes stimulusPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        .choice-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .choice-btn {
            width: 150px;
            height: 150px;
            font-size: 18px;
            border-radius: 10px;
        }

        .choice-btn.left {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .choice-btn.right {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        /* Trial Feedback */
        .trial-feedback {
            font-size: 24px;
            margin: 20px 0;
            padding: 20px;
            border: 2px solid var(--neon-green);
            background: var(--bg-dark);
        }

        .trial-feedback.false-start {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }

        .trial-feedback.correct {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .trial-feedback.incorrect {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        /* Results Dashboard */
        .results {
            background: var(--bg-dark);
            border: 2px solid var(--neon-green);
            padding: 30px;
            margin: 20px 0;
        }

        .results h2 {
            color: var(--neon-cyan);
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            background: var(--bg-black);
            border: 1px solid var(--neon-green);
            padding: 20px;
            text-align: center;
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .stat-value {
            color: var(--neon-green);
            font-size: 28px;
            font-weight: bold;
        }

        .chart-container {
            margin: 30px 0;
            background: var(--bg-black);
            padding: 20px;
            border: 1px solid var(--neon-green);
        }

        .chart-title {
            color: var(--neon-cyan);
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: auto !important;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Terminal Log */
        .terminal-log {
            background: var(--bg-black);
            border: 1px solid var(--neon-green);
            padding: 15px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            color: var(--neon-green);
            margin: 3px 0;
            opacity: 0.8;
        }

        .log-entry.error {
            color: var(--neon-pink);
        }

        /* Controls Bar */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        /* Toggle Switches */
        .toggle-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            padding: 20px;
            background: var(--bg-dark);
            border: 1px solid var(--text-dim);
            margin: 20px 0;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 30px 20px;
            border-top: 1px solid var(--text-dim);
            margin-top: 50px;
            font-size: 12px;
            color: var(--text-dim);
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* High Contrast Mode */
        body.high-contrast {
            --neon-green: #ffffff;
            --neon-cyan: #ffffff;
            --bg-black: #000000;
            --bg-dark: #000000;
            --text-gray: #ffffff;
        }

        body.high-contrast button {
            border-width: 3px;
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        body.reduced-motion * {
            animation: none !important;
            transition: none !important;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            button {
                padding: 12px 20px;
                font-size: 14px;
            }

            .start-btn {
                font-size: 16px;
                padding: 15px 30px;
            }

            .choice-btn {
                width: 120px;
                height: 120px;
                font-size: 16px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .stimulus-circle {
                width: 150px;
                height: 150px;
            }

            .test-area {
                min-height: 300px;
                padding: 20px;
            }
        }

        /* Touch targets for mobile */
        @media (pointer: coarse) {
            button {
                min-height: 48px;
                min-width: 48px;
            }
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Canvas -->
    <canvas id="matrix-canvas"></canvas>
    
    <!-- Scanlines Overlay -->
    <div class="scanlines"></div>
    
    <!-- Vignette Overlay -->
    <div class="vignette"></div>

    <div class="container">
        <!-- Header -->
        <header>
            <div class="ascii-logo" aria-label="MAQSADBEK Logo">
███╗   ███╗ █████╗  ██████╗ ███████╗ █████╗ ██████╗ ██████╗ ███████╗██╗  ██╗
████╗ ████║██╔══██╗██╔═══██╗██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██║ ██╔╝
██╔████╔██║███████║██║   ██║███████╗███████║██║  ██║██████╔╝█████╗  █████╔╝ 
██║╚██╔╝██║██╔══██║██║▄▄ ██║╚════██║██╔══██║██║  ██║██╔══██╗██╔══╝  ██╔═██╗ 
██║ ╚═╝ ██║██║  ██║╚██████╔╝███████║██║  ██║██████╔╝██████╔╝███████╗██║  ██║
╚═╝     ╚═╝╚═╝  ╚═╝ ╚══▀▀═╝ ╚══════╝╚═╝  ╚═╝╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
            </div>
            <div class="subtitle">REACTION TIME TESTER V1.0</div>
        </header>

        <!-- Global Toggles -->
        <div class="toggle-group">
            <div class="toggle-item">
                <input type="checkbox" id="matrix-toggle" aria-label="Toggle Matrix Rain Background">
                <label for="matrix-toggle">Matrix Rain</label>
            </div>
            <div class="toggle-item">
                <input type="checkbox" id="scanlines-toggle" aria-label="Toggle Scanlines Effect">
                <label for="scanlines-toggle">Scanlines</label>
            </div>
            <div class="toggle-item">
                <input type="checkbox" id="vignette-toggle" aria-label="Toggle CRT Vignette">
                <label for="vignette-toggle">CRT Vignette</label>
            </div>
            <div class="toggle-item">
                <input type="checkbox" id="reduced-motion-toggle" aria-label="Toggle Reduced Motion">
                <label for="reduced-motion-toggle">Reduced Motion</label>
            </div>
            <div class="toggle-item">
                <input type="checkbox" id="high-contrast-toggle" aria-label="Toggle High Contrast Mode">
                <label for="high-contrast-toggle">High Contrast</label>
            </div>
            <div class="toggle-item">
                <input type="checkbox" id="storage-consent" aria-label="Remember My Runs in Browser Storage">
                <label for="storage-consent">Remember My Runs</label>
            </div>
        </div>

        <!-- Landing Screen -->
        <div class="screen active" id="landing-screen">
            <div class="landing">
                <h1>Test Your Reaction Time</h1>
                <p>
                    Measure your reflexes with scientifically-sound tests using high-precision timing.
                    Choose from multiple test modes including simple reaction, auditory, choice reaction, 
                    go/no-go, and sequence tests. Get detailed statistics and track your progress.
                </p>
                <p>
                    <strong>How it works:</strong> A stimulus will appear after a random delay. 
                    Respond as quickly as possible. Your reaction time is measured from stimulus 
                    onset to your response with sub-millisecond precision using performance.now().
                </p>
                <button class="start-btn" onclick="showSettings()">START TEST</button>
                <button class="start-btn secondary" onclick="showHistory()">VIEW HISTORY</button>
            </div>
        </div>

        <!-- Settings Screen -->
        <div class="screen" id="settings-screen">
            <div class="settings">
                <h2 style="color: var(--neon-cyan); text-align: center; margin-bottom: 30px;">TEST SETTINGS</h2>
                
                <div class="setting-group">
                    <label for="test-mode">Test Mode</label>
                    <select id="test-mode" aria-label="Select Test Mode">
                        <option value="simple">Simple Reaction - React to visual stimulus</option>
                        <option value="auditory">Auditory Reaction - React to sound</option>
                        <option value="choice">Choice Reaction - Choose correct response</option>
                        <option value="gonogo">Go/No-Go - Respond only to target stimulus</option>
                        <option value="sequence">Sequence Reaction - Multiple rapid responses</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="trial-count">Number of Trials</label>
                    <input type="number" id="trial-count" min="5" max="50" value="10" aria-label="Number of Trials">
                </div>

                <div class="setting-group">
                    <label for="min-delay">Minimum Delay (ms)</label>
                    <input type="number" id="min-delay" min="500" max="5000" value="1000" step="100" aria-label="Minimum Stimulus Delay">
                </div>

                <div class="setting-group">
                    <label for="max-delay">Maximum Delay (ms)</label>
                    <input type="number" id="max-delay" min="500" max="10000" value="3000" step="100" aria-label="Maximum Stimulus Delay">
                </div>

                <div class="setting-group checkbox-group">
                    <input type="checkbox" id="sound-enabled" checked aria-label="Enable Sound Effects">
                    <label for="sound-enabled">Enable Sound Effects</label>
                </div>

                <div class="setting-group checkbox-group">
                    <input type="checkbox" id="auto-advance" checked aria-label="Auto-advance to Next Trial">
                    <label for="auto-advance">Auto-advance to Next Trial</label>
                </div>

                <div class="controls">
                    <button onclick="startTest()">BEGIN TEST</button>
                    <button class="secondary" onclick="showLanding()">BACK</button>
                </div>
            </div>
        </div>

        <!-- Test Screen -->
        <div class="screen" id="test-screen">
            <div class="test-area" id="test-area" tabindex="0" aria-label="Test Area - Press Space or Click to Respond">
                <div class="test-instruction" id="test-instruction">Get Ready...</div>
                <div id="stimulus-container"></div>
            </div>

            <div class="trial-feedback" id="trial-feedback" style="display: none;"></div>

            <div class="terminal-log" id="test-log" aria-live="polite" aria-label="Test Activity Log"></div>

            <div class="controls">
                <button onclick="skipTrial()" id="skip-btn">SKIP TRIAL</button>
                <button class="secondary" onclick="abortTest()">ABORT TEST</button>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="results-screen">
            <div class="results">
                <h2>TEST RESULTS</h2>
                
                <div class="stats-grid" id="stats-grid"></div>

                <div class="chart-container">
                    <div class="chart-title">Reaction Time Distribution</div>
                    <canvas id="histogram-canvas" width="800" height="300"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Trial Timeline</div>
                    <canvas id="timeline-canvas" width="800" height="250"></canvas>
                </div>

                <div class="terminal-log" id="results-log" aria-live="polite"></div>

                <div class="controls">
                    <button onclick="shareResults()">SHARE RESULTS</button>
                    <button onclick="exportCSV()">EXPORT CSV</button>
                    <button onclick="saveToHistory()">SAVE TO HISTORY</button>
                    <button class="secondary" onclick="showLanding()">NEW TEST</button>
                </div>
            </div>
        </div>

        <!-- History Screen -->
        <div class="screen" id="history-screen">
            <div class="results">
                <h2>TEST HISTORY</h2>
                <div id="history-container"></div>
                <div class="controls">
                    <button onclick="clearHistory()">CLEAR HISTORY</button>
                    <button class="secondary" onclick="showLanding()">BACK</button>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer>
            <p>MAQSADBEK Reaction Time Tester | No data sent to servers | Privacy-first design</p>
            <p>All timing measurements use performance.now() for sub-millisecond accuracy</p>
            <p>Data stored locally in your browser only with your consent</p>
        </footer>
    </div>

    <script>
        /*
         * REACTION TIME TESTER - TECHNICAL IMPLEMENTATION
         * 
         * TIMING METHODOLOGY:
         * - performance.now() provides microsecond-precision timestamps (DOMHighResTimeStamp)
         * - Visual stimuli synchronized with requestAnimationFrame to ensure accurate onset timing
         * - Audio stimuli scheduled via WebAudio API for precise playback timing
         * - Reaction time = response_time - stimulus_onset_time
         * 
         * ACCURACY CONSIDERATIONS:
         * - Browser rendering pipeline introduces ~1-2 frame delays (16-32ms @ 60Hz)
         * - Input device latency varies: mouse ~10-50ms, touch ~50-200ms
         * - Display refresh rate affects stimulus presentation (60Hz, 120Hz, etc.)
         * - Audio latency typically 5-50ms depending on system
         * 
         * CALIBRATION:
         * - Measures system-specific latency using rapid test sequences
         * - Can subtract average device latency from results for more accurate measurements
         * 
         * CUSTOMIZATION:
         * - Default trial count: 10 (line 850)
         * - Default delay range: 1000-3000ms (line 851-852)
         * - Color scheme: CSS variables (line 18-25)
         * - False start threshold: response before stimulus onset
         * 
         * ADDING SERVER LEADERBOARD:
         * To add a shared leaderboard via Vercel serverless functions:
         * 1. Create /api/leaderboard.js endpoint
         * 2. Store results in Vercel KV or PostgreSQL
         * 3. Modify saveToHistory() to also POST to /api/leaderboard
         * 4. Add getLeaderboard() function to fetch and display top scores
         * 5. Include user identifier (username or anonymous ID)
         */

        // ============= STATE MANAGEMENT =============
        const state = {
            currentScreen: 'landing',
            testMode: 'simple',
            trialCount: 10,
            currentTrial: 0,
            minDelay: 1000,
            maxDelay: 3000,
            soundEnabled: true,
            autoAdvance: true,
            
            // Test execution
            testActive: false,
            waitingForStimulus: false,
            stimulusTime: null,
            trialStartTime: null,
            
            // Mode-specific state
            currentCorrectSide: null,
            currentIsGo: null,
            noGoTimeout: null,
            sequenceCount: 0,
            sequenceMax: 5,
            sequenceResponses: [],
            
            // Results
            results: [],
            currentRun: null,
            
            // Audio
            audioContext: null,
            beepBuffer: null
        };

        // ============= AUDIO SETUP =============
        function initAudio() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create simple beep sound
                const sampleRate = state.audioContext.sampleRate;
                const duration = 0.1;
                const frequency = 800;
                const buffer = state.audioContext.createBuffer(1, sampleRate * duration, sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 
                             Math.exp(-3 * i / buffer.length);
                }
                
                state.beepBuffer = buffer;
            }
        }

        function playBeep(when = 0) {
            if (!state.soundEnabled || !state.audioContext) return;
            
            try {
                const source = state.audioContext.createBufferSource();
                source.buffer = state.beepBuffer;
                source.connect(state.audioContext.destination);
                source.start(state.audioContext.currentTime + when);
                
                return state.audioContext.currentTime + when;
            } catch (e) {
                console.error('Audio playback error:', e);
            }
        }

        // ============= MATRIX RAIN EFFECT =============
        function initMatrixRain() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const chars = 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ01';
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);
            
            function draw() {
                ctx.fillStyle = 'rgba(11, 11, 11, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#39ff14';
                ctx.font = fontSize + 'px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            let animationId;
            function animate() {
                draw();
                animationId = requestAnimationFrame(animate);
            }
            
            const matrixToggle = document.getElementById('matrix-toggle');
            matrixToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    canvas.classList.add('active');
                    animate();
                } else {
                    canvas.classList.remove('active');
                    cancelAnimationFrame(animationId);
                }
            });
        }

        // ============= SCREEN NAVIGATION =============
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            state.currentScreen = screenId;
        }

        function showLanding() {
            showScreen('landing-screen');
        }

        function showSettings() {
            showScreen('settings-screen');
        }

        function showHistory() {
            loadHistory();
            showScreen('history-screen');
        }

        // ============= LOGGING =============
        function log(message, isError = false) {
            const logEl = document.getElementById('test-log');
            if (logEl) {
                const entry = document.createElement('div');
                entry.className = 'log-entry' + (isError ? ' error' : '');
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;
            }
        }

        // ============= TEST EXECUTION =============
        function startTest() {
            // Get settings
            state.testMode = document.getElementById('test-mode').value;
            state.trialCount = parseInt(document.getElementById('trial-count').value);
            state.minDelay = parseInt(document.getElementById('min-delay').value);
            state.maxDelay = parseInt(document.getElementById('max-delay').value);
            state.soundEnabled = document.getElementById('sound-enabled').checked;
            state.autoAdvance = document.getElementById('auto-advance').checked;
            
            // Initialize audio if needed
            if (state.soundEnabled) {
                initAudio();
            }
            
            // Reset state
            state.currentTrial = 0;
            state.results = [];
            state.testActive = true;
            
            // Clear log
            document.getElementById('test-log').innerHTML = '';
            
            // Show test screen
            showScreen('test-screen');
            
            log(`Starting ${state.testMode} reaction test with ${state.trialCount} trials`);
            log(`Delay range: ${state.minDelay}-${state.maxDelay}ms`);
            
            // Start first trial after brief delay
            setTimeout(() => runTrial(), 1000);
        }

        function runTrial() {
            if (state.currentTrial >= state.trialCount) {
                finishTest();
                return;
            }
            
            state.currentTrial++;
            log(`Trial ${state.currentTrial}/${state.trialCount} - Preparing...`);
            
            const testArea = document.getElementById('test-area');
            const instruction = document.getElementById('test-instruction');
            const stimulusContainer = document.getElementById('stimulus-container');
            const feedback = document.getElementById('trial-feedback');
            
            // Clear previous
            stimulusContainer.innerHTML = '';
            feedback.style.display = 'none';
            
            // Show countdown
            instruction.textContent = 'Get Ready...';
            let countdown = 3;
            const countdownEl = document.createElement('div');
            countdownEl.className = 'countdown';
            countdownEl.textContent = countdown;
            stimulusContainer.appendChild(countdownEl);
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    if (state.soundEnabled) playBeep();
                } else {
                    clearInterval(countdownInterval);
                    stimulusContainer.innerHTML = '';
                    presentStimulus();
                }
            }, 1000);
        }

        function presentStimulus() {
            const instruction = document.getElementById('test-instruction');
            const stimulusContainer = document.getElementById('stimulus-container');
            
            // Random delay before stimulus
            const delay = state.minDelay + Math.random() * (state.maxDelay - state.minDelay);
            
            state.waitingForStimulus = true;
            state.trialStartTime = performance.now();
            
            instruction.textContent = 'Wait for it...';
            log(`Waiting ${Math.round(delay)}ms for stimulus...`);
            
            // Setup response handler
            setupResponseHandler();
            
            setTimeout(() => {
                if (!state.testActive) return;
                
                // Record precise stimulus onset time
                requestAnimationFrame(() => {
                    state.stimulusTime = performance.now();
                    state.waitingForStimulus = false;
                    
                    // Present appropriate stimulus based on mode
                    switch (state.testMode) {
                        case 'simple':
                            presentSimpleStimulus();
                            break;
                        case 'auditory':
                            presentAuditoryStimulus();
                            break;
                        case 'choice':
                            presentChoiceStimulus();
                            break;
                        case 'gonogo':
                            presentGoNoGoStimulus();
                            break;
                        case 'sequence':
                            presentSequenceStimulus();
                            break;
                    }
                });
            }, delay);
        }

        function presentSimpleStimulus() {
            const instruction = document.getElementById('test-instruction');
            const stimulusContainer = document.getElementById('stimulus-container');
            
            instruction.textContent = 'CLICK NOW!';
            
            const circle = document.createElement('div');
            circle.className = 'stimulus-circle';
            stimulusContainer.appendChild(circle);
            
            log('Visual stimulus presented');
        }

        function presentAuditoryStimulus() {
            const instruction = document.getElementById('test-instruction');
            
            instruction.textContent = 'RESPOND TO SOUND!';
            
            if (state.soundEnabled && state.audioContext) {
                playBeep();
                log('Auditory stimulus presented');
            } else {
                log('Audio not available - enable sound in settings', true);
                presentSimpleStimulus();
            }
        }

        function presentChoiceStimulus() {
            const instruction = document.getElementById('test-instruction');
            const stimulusContainer = document.getElementById('stimulus-container');
            
            const isLeft = Math.random() < 0.5;
            state.currentCorrectSide = isLeft ? 'left' : 'right';
            
            instruction.textContent = `Press ${isLeft ? 'LEFT' : 'RIGHT'} (or ← →)`;
            
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'choice-buttons';
            
            const leftBtn = document.createElement('button');
            leftBtn.className = 'choice-btn left';
            leftBtn.textContent = 'LEFT\n←';
            leftBtn.onclick = () => recordResponse('left');
            if (isLeft) leftBtn.style.background = 'var(--neon-green)';
            
            const rightBtn = document.createElement('button');
            rightBtn.className = 'choice-btn right';
            rightBtn.textContent = 'RIGHT\n→';
            rightBtn.onclick = () => recordResponse('right');
            if (!isLeft) rightBtn.style.background = 'var(--neon-cyan)';
            
            buttonsDiv.appendChild(leftBtn);
            buttonsDiv.appendChild(rightBtn);
            stimulusContainer.appendChild(buttonsDiv);
            
            log(`Choice stimulus presented: ${isLeft ? 'LEFT' : 'RIGHT'}`);
        }

        function presentGoNoGoStimulus() {
            const instruction = document.getElementById('test-instruction');
            const stimulusContainer = document.getElementById('stimulus-container');
            
            const isGo = Math.random() < 0.7; // 70% go trials
            state.currentIsGo = isGo;
            
            // Clear any previous no-go timeout
            if (state.noGoTimeout) {
                clearTimeout(state.noGoTimeout);
                state.noGoTimeout = null;
            }
            
            instruction.textContent = isGo ? 'GO - CLICK NOW!' : 'NO-GO - DO NOT CLICK!';
            
            const circle = document.createElement('div');
            circle.className = 'stimulus-circle';
            circle.style.background = isGo ? 'var(--neon-green)' : 'var(--neon-pink)';
            circle.style.boxShadow = isGo ? 'var(--glow-green)' : '0 0 10px var(--neon-pink)';
            stimulusContainer.appendChild(circle);
            
            log(`Go/No-Go stimulus: ${isGo ? 'GO' : 'NO-GO'}`);
            
            if (!isGo) {
                // Auto-advance after delay on no-go trials if no response
                state.noGoTimeout = setTimeout(() => {
                    if (state.testActive && state.currentIsGo === false) {
                        // No response = correct for no-go
                        recordResult({
                            trial: state.currentTrial,
                            rt: null,
                            correct: true,
                            falseStart: false,
                            type: 'nogo-correct'
                        });
                        
                        showTrialFeedback('Correct! (No response on No-Go)', true);
                        
                        state.noGoTimeout = null;
                        
                        if (state.autoAdvance) {
                            setTimeout(() => runTrial(), 1500);
                        }
                    }
                }, 2000);
            }
        }

        function presentSequenceStimulus() {
            // Initialize sequence for this trial
            state.sequenceCount = 0;
            state.sequenceResponses = [];
            presentSequenceItem();
        }

        function presentSequenceItem() {
            const instruction = document.getElementById('test-instruction');
            instruction.textContent = `Sequence ${state.sequenceCount + 1}/${state.sequenceMax} - CLICK!`;
            
            presentSimpleStimulus();
            log(`Sequence item ${state.sequenceCount + 1}/${state.sequenceMax} presented`);
        }

        function setupResponseHandler() {
            const testArea = document.getElementById('test-area');
            
            // Remove old handlers
            const newTestArea = testArea.cloneNode(true);
            testArea.parentNode.replaceChild(newTestArea, testArea);
            
            const clickHandler = (e) => {
                if (e.target.closest('button')) return; // Ignore button clicks
                recordResponse('click');
            };
            
            const keyHandler = (e) => {
                if (e.code === 'Space' || e.code === 'Enter') {
                    e.preventDefault();
                    recordResponse('space');
                } else if (e.code === 'ArrowLeft') {
                    e.preventDefault();
                    recordResponse('left');
                } else if (e.code === 'ArrowRight') {
                    e.preventDefault();
                    recordResponse('right');
                }
            };
            
            document.getElementById('test-area').addEventListener('click', clickHandler);
            document.getElementById('test-area').addEventListener('keydown', keyHandler);
        }

        function recordResponse(responseType) {
            if (!state.testActive) return;
            
            const responseTime = performance.now();
            
            // Check for false start
            if (state.waitingForStimulus) {
                log('False start detected!', true);
                
                recordResult({
                    trial: state.currentTrial,
                    rt: null,
                    correct: false,
                    falseStart: true,
                    type: 'false-start'
                });
                
                showTrialFeedback('FALSE START! Wait for the stimulus.', false);
                
                if (state.autoAdvance) {
                    setTimeout(() => runTrial(), 2000);
                }
                return;
            }
            
            // Clear no-go timeout if user responded (commission error on no-go trial)
            if (state.noGoTimeout) {
                clearTimeout(state.noGoTimeout);
                state.noGoTimeout = null;
            }
            
            // Calculate reaction time
            const rt = responseTime - state.stimulusTime;
            
            // Check correctness based on mode
            let correct = true;
            if (state.testMode === 'choice') {
                correct = responseType === state.currentCorrectSide;
            } else if (state.testMode === 'gonogo') {
                correct = state.currentIsGo; // Should only respond on go trials
                if (!correct) {
                    log('Commission error: Response on No-Go trial', true);
                }
            }
            
            log(`Response recorded: ${Math.round(rt)}ms - ${correct ? 'Correct' : 'Incorrect'}`);
            
            // Handle sequence mode differently - accumulate all responses first
            if (state.testMode === 'sequence') {
                // Add this response to the sequence
                state.sequenceResponses.push({rt: rt, correct: correct});
                state.sequenceCount++;
                
                showTrialFeedback(`Sequence ${state.sequenceCount}/${state.sequenceMax}: ${Math.round(rt)}ms`, correct);
                
                // Check if sequence is complete
                if (state.sequenceCount >= state.sequenceMax) {
                    // All 5 stimuli completed - now aggregate and record the trial result
                    const validResponses = state.sequenceResponses.filter(r => r.rt !== null);
                    const meanRT = validResponses.reduce((sum, r) => sum + r.rt, 0) / validResponses.length;
                    const correctCount = state.sequenceResponses.filter(r => r.correct).length;
                    const accuracy = (correctCount / state.sequenceMax) * 100;
                    
                    log(`Sequence complete: ${correctCount}/${state.sequenceMax} correct, mean RT: ${Math.round(meanRT)}ms`);
                    
                    // Record ONE aggregated result for the entire sequence
                    const resultData = {
                        trial: state.currentTrial,
                        rt: meanRT,
                        correct: correctCount === state.sequenceMax,
                        falseStart: false,
                        type: 'sequence',
                        sequenceResponses: state.sequenceResponses,
                        sequenceAccuracy: accuracy,
                        sequenceCorrect: correctCount,
                        sequenceTotal: state.sequenceMax
                    };
                    
                    recordResult(resultData);
                    
                    // Auto-advance to next trial after the full sequence
                    if (state.autoAdvance) {
                        setTimeout(() => runTrial(), 1500);
                    }
                } else {
                    // More stimuli to present - show next item in sequence
                    setTimeout(() => {
                        document.getElementById('stimulus-container').innerHTML = '';
                        document.getElementById('trial-feedback').style.display = 'none';
                        
                        requestAnimationFrame(() => {
                            state.stimulusTime = performance.now();
                            presentSequenceItem();
                        });
                    }, 500);
                }
            } else {
                // Non-sequence modes - record result immediately as before
                const resultData = {
                    trial: state.currentTrial,
                    rt: rt,
                    correct: correct,
                    falseStart: false,
                    type: state.testMode,
                    responseType: responseType
                };
                
                recordResult(resultData);
                
                showTrialFeedback(`${Math.round(rt)}ms - ${correct ? 'Correct!' : 'Incorrect'}`, correct);
                
                // Advance to next trial
                if (state.autoAdvance) {
                    setTimeout(() => runTrial(), 1500);
                }
            }
        }

        function recordResult(result) {
            state.results.push(result);
        }

        function showTrialFeedback(message, isCorrect) {
            const feedback = document.getElementById('trial-feedback');
            feedback.textContent = message;
            feedback.className = 'trial-feedback';
            
            if (message.includes('FALSE START')) {
                feedback.classList.add('false-start');
            } else if (isCorrect) {
                feedback.classList.add('correct');
            } else {
                feedback.classList.add('incorrect');
            }
            
            feedback.style.display = 'block';
        }

        function skipTrial() {
            log('Trial skipped by user');
            if (state.autoAdvance) {
                runTrial();
            }
        }

        function abortTest() {
            state.testActive = false;
            log('Test aborted by user');
            showLanding();
        }

        function finishTest() {
            state.testActive = false;
            log('Test complete!');
            
            // Calculate statistics
            const validResults = state.results.filter(r => r.rt !== null && !r.falseStart);
            const reactionTimes = validResults.map(r => r.rt);
            
            if (reactionTimes.length === 0) {
                alert('No valid trials completed. Please try again.');
                showLanding();
                return;
            }
            
            const stats = calculateStatistics(reactionTimes);
            const falseStarts = state.results.filter(r => r.falseStart).length;
            const incorrectCount = state.results.filter(r => !r.correct && !r.falseStart).length;
            
            state.currentRun = {
                date: new Date().toISOString(),
                mode: state.testMode,
                totalTrials: state.trialCount,
                completedTrials: state.results.length,
                validTrials: validResults.length,
                stats: stats,
                falseStarts: falseStarts,
                incorrectCount: incorrectCount,
                accuracy: ((validResults.filter(r => r.correct).length / validResults.length) * 100).toFixed(1),
                results: state.results
            };
            
            displayResults();
        }

        function calculateStatistics(values) {
            if (values.length === 0) return {};
            
            const sorted = [...values].sort((a, b) => a - b);
            const sum = sorted.reduce((a, b) => a + b, 0);
            const mean = sum / sorted.length;
            
            const median = sorted.length % 2 === 0
                ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                : sorted[Math.floor(sorted.length / 2)];
            
            const variance = sorted.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / sorted.length;
            const stdDev = Math.sqrt(variance);
            
            return {
                mean: mean,
                median: median,
                min: sorted[0],
                max: sorted[sorted.length - 1],
                stdDev: stdDev
            };
        }

        function displayResults() {
            showScreen('results-screen');
            
            const run = state.currentRun;
            const statsGrid = document.getElementById('stats-grid');
            
            const correctCount = run.results.filter(r => r.correct && !r.falseStart).length;
            const incorrectCount = run.results.filter(r => !r.correct && !r.falseStart).length;
            
            statsGrid.innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Mean RT</div>
                    <div class="stat-value">${Math.round(run.stats.mean)}ms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Median RT</div>
                    <div class="stat-value">${Math.round(run.stats.median)}ms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Best (Fastest)</div>
                    <div class="stat-value">${Math.round(run.stats.min)}ms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Worst (Slowest)</div>
                    <div class="stat-value">${Math.round(run.stats.max)}ms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Std Deviation</div>
                    <div class="stat-value">${Math.round(run.stats.stdDev)}ms</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value">${run.accuracy}%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Correct</div>
                    <div class="stat-value">${correctCount}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Incorrect</div>
                    <div class="stat-value">${incorrectCount}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">False Starts</div>
                    <div class="stat-value">${run.falseStarts}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Valid Trials</div>
                    <div class="stat-value">${run.validTrials}/${run.totalTrials}</div>
                </div>
            `;
            
            // Draw charts
            drawHistogram(run.results.filter(r => r.rt !== null).map(r => r.rt));
            drawTimeline(run.results);
            
            // Results log
            const resultsLog = document.getElementById('results-log');
            resultsLog.innerHTML = `
                <div class="log-entry">Test Mode: ${run.mode.toUpperCase()}</div>
                <div class="log-entry">Date: ${new Date(run.date).toLocaleString()}</div>
                <div class="log-entry">Trials Completed: ${run.completedTrials}/${run.totalTrials}</div>
                <div class="log-entry">Mean Reaction Time: ${Math.round(run.stats.mean)}ms</div>
                <div class="log-entry">Range: ${Math.round(run.stats.min)}ms - ${Math.round(run.stats.max)}ms</div>
            `;
        }

        function drawHistogram(data) {
            const canvas = document.getElementById('histogram-canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (data.length === 0) return;
            
            // Create bins
            const binCount = Math.min(10, data.length);
            const min = Math.min(...data);
            const max = Math.max(...data);
            const binWidth = (max - min) / binCount;
            
            const bins = Array(binCount).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
                bins[binIndex]++;
            });
            
            const maxBinValue = Math.max(...bins);
            
            // Draw histogram
            const padding = 40;
            const chartWidth = canvas.width - padding * 2;
            const chartHeight = canvas.height - padding * 2;
            const barWidth = chartWidth / binCount;
            
            ctx.fillStyle = '#39ff14';
            ctx.strokeStyle = '#39ff14';
            
            bins.forEach((count, i) => {
                const barHeight = (count / maxBinValue) * chartHeight;
                const x = padding + i * barWidth;
                const y = canvas.height - padding - barHeight;
                
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
                
                // Labels
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                const binLabel = Math.round(min + i * binWidth);
                ctx.fillText(binLabel, x + barWidth / 2, canvas.height - 20);
                ctx.fillStyle = '#39ff14';
            });
            
            // Axes
            ctx.strokeStyle = '#606060';
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Reaction Time (ms)', canvas.width / 2, canvas.height - 5);
            
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Frequency', 0, 0);
            ctx.restore();
        }

        function drawTimeline(data) {
            const canvas = document.getElementById('timeline-canvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const validData = data.filter(r => r.rt !== null);
            if (validData.length === 0) return;
            
            const padding = 40;
            const chartWidth = canvas.width - padding * 2;
            const chartHeight = canvas.height - padding * 2;
            
            const maxRT = Math.max(...validData.map(r => r.rt));
            const minRT = Math.min(...validData.map(r => r.rt));
            const range = maxRT - minRT;
            
            // Draw line
            ctx.strokeStyle = '#00f5ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            validData.forEach((result, i) => {
                const x = padding + (i / (validData.length - 1)) * chartWidth;
                const y = canvas.height - padding - ((result.rt - minRT) / range) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            validData.forEach((result, i) => {
                const x = padding + (i / (validData.length - 1)) * chartWidth;
                const y = canvas.height - padding - ((result.rt - minRT) / range) * chartHeight;
                
                ctx.fillStyle = result.correct ? '#39ff14' : '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Axes
            ctx.strokeStyle = '#606060';
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Trial Number', canvas.width / 2, canvas.height - 5);
            
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Reaction Time (ms)', 0, 0);
            ctx.restore();
        }

        // ============= DATA EXPORT & SHARING =============
        function shareResults() {
            const run = state.currentRun;
            const text = `MAQSADBEK Reaction Time Test Results
Mode: ${run.mode.toUpperCase()}
Date: ${new Date(run.date).toLocaleString()}
Trials: ${run.validTrials}/${run.totalTrials}
Mean: ${Math.round(run.stats.mean)}ms
Median: ${Math.round(run.stats.median)}ms
Best: ${Math.round(run.stats.min)}ms
Worst: ${Math.round(run.stats.max)}ms
Std Dev: ${Math.round(run.stats.stdDev)}ms
Accuracy: ${run.accuracy}%
False Starts: ${run.falseStarts}

Test yourself at: maqsadbek37.vercel.app`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard!');
                }).catch(err => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                alert('Results copied to clipboard!');
            } catch (err) {
                alert('Could not copy results. Please copy manually.');
            }
            document.body.removeChild(textarea);
        }

        function exportCSV() {
            const run = state.currentRun;
            let csv = 'Trial,Reaction Time (ms),Correct,False Start,Type\n';
            
            run.results.forEach((result, i) => {
                csv += `${i + 1},${result.rt || 'N/A'},${result.correct},${result.falseStart},${result.type}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `reaction-test-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function saveToHistory() {
            const consent = document.getElementById('storage-consent').checked;
            
            if (!consent) {
                alert('Please enable "Remember My Runs" to save test results to browser storage.');
                return;
            }
            
            try {
                let history = JSON.parse(localStorage.getItem('reactionTestHistory') || '[]');
                history.push(state.currentRun);
                
                // Keep only last 50 runs
                if (history.length > 50) {
                    history = history.slice(-50);
                }
                
                localStorage.setItem('reactionTestHistory', JSON.stringify(history));
                alert('Results saved to history!');
            } catch (e) {
                alert('Could not save to history: ' + e.message);
            }
        }

        function loadHistory() {
            const container = document.getElementById('history-container');
            
            try {
                const history = JSON.parse(localStorage.getItem('reactionTestHistory') || '[]');
                
                if (history.length === 0) {
                    container.innerHTML = '<p style="text-align: center; padding: 40px;">No saved test runs yet.</p>';
                    return;
                }
                
                container.innerHTML = '';
                
                history.reverse().forEach((run, index) => {
                    const runDiv = document.createElement('div');
                    runDiv.className = 'stat-box';
                    runDiv.style.marginBottom = '20px';
                    runDiv.innerHTML = `
                        <div class="stat-label">${new Date(run.date).toLocaleString()}</div>
                        <div style="color: var(--neon-cyan); margin: 10px 0;">Mode: ${run.mode.toUpperCase()}</div>
                        <div>Mean: ${Math.round(run.stats.mean)}ms | Median: ${Math.round(run.stats.median)}ms</div>
                        <div>Best: ${Math.round(run.stats.min)}ms | Worst: ${Math.round(run.stats.max)}ms</div>
                        <div>Accuracy: ${run.accuracy}% | False Starts: ${run.falseStarts}</div>
                    `;
                    container.appendChild(runDiv);
                });
            } catch (e) {
                container.innerHTML = '<p style="text-align: center; padding: 40px; color: var(--neon-pink);">Error loading history.</p>';
            }
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all saved test results?')) {
                localStorage.removeItem('reactionTestHistory');
                loadHistory();
                alert('History cleared.');
            }
        }

        // ============= INITIALIZATION =============
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize matrix rain
            initMatrixRain();
            
            // Setup toggles
            document.getElementById('scanlines-toggle').addEventListener('change', (e) => {
                document.querySelector('.scanlines').classList.toggle('active', e.target.checked);
            });
            
            document.getElementById('vignette-toggle').addEventListener('change', (e) => {
                document.querySelector('.vignette').classList.toggle('active', e.target.checked);
            });
            
            document.getElementById('reduced-motion-toggle').addEventListener('change', (e) => {
                document.body.classList.toggle('reduced-motion', e.target.checked);
            });
            
            document.getElementById('high-contrast-toggle').addEventListener('change', (e) => {
                document.body.classList.toggle('high-contrast', e.target.checked);
            });
            
            // Check for storage consent in localStorage
            try {
                const consent = localStorage.getItem('storageConsent');
                if (consent === 'true') {
                    document.getElementById('storage-consent').checked = true;
                }
            } catch (e) {
                // localStorage not available
            }
            
            document.getElementById('storage-consent').addEventListener('change', (e) => {
                try {
                    localStorage.setItem('storageConsent', e.target.checked);
                } catch (err) {
                    // Ignore
                }
            });
        });
    </script>
</body>
</html>
